from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QPixmap
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QComboBox, QSpinBox, QDoubleSpinBox, QGroupBox, QFormLayout, QFileDialog,
)

import cv2
import numpy as np

from services import contour_tools as ct


class EdgeTunerDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Edge/Contour Tuner")
        self.resize(900, 680)
        self._img_path = None
        self._path_label = QLabel("Image: (none)")
        self._path_label.setStyleSheet("color: #ccc;")
        self._preview = QLabel("Choose an image first")
        self._preview.setAlignment(Qt.AlignCenter)
        self._preview.setStyleSheet("background: #111;")

        # Controls
        frm = QFormLayout()
        self.combo_method = QComboBox()
        self.combo_method.addItems(["auto", "binary", "binary_inv", "canny"])
        default_method = str(ct.DEFAULT_PARAMS.get("method", "auto")).lower()
        idx = self.combo_method.findText(default_method) if default_method else -1
        if idx >= 0:
            self.combo_method.setCurrentIndex(idx)
        frm.addRow("Method", self.combo_method)

        self.spin_blur = QSpinBox(); self.spin_blur.setRange(1, 31); self.spin_blur.setSingleStep(2); self.spin_blur.setValue(int(ct.DEFAULT_PARAMS["blur"]))
        frm.addRow("Blur (odd)", self.spin_blur)

        self.spin_morph = QSpinBox(); self.spin_morph.setRange(1, 31); self.spin_morph.setValue(int(ct.DEFAULT_PARAMS["morph"]))
        frm.addRow("Morph kernel", self.spin_morph)

        self.spin_morph_iter = QSpinBox(); self.spin_morph_iter.setRange(0, 5); self.spin_morph_iter.setValue(int(ct.DEFAULT_PARAMS["morph_iter"]))
        frm.addRow("Morph iter", self.spin_morph_iter)

        self.spin_eps = QDoubleSpinBox(); self.spin_eps.setRange(0.0, 10.0); self.spin_eps.setDecimals(1); self.spin_eps.setValue(float(ct.DEFAULT_PARAMS["approx_eps"]))
        frm.addRow("Approx eps", self.spin_eps)

        self.spin_th_off = QDoubleSpinBox(); self.spin_th_off.setRange(-50.0, 50.0); self.spin_th_off.setDecimals(1); self.spin_th_off.setValue(float(ct.DEFAULT_PARAMS["thresh_offset"]))
        frm.addRow("Thresh offset", self.spin_th_off)

        self.spin_c1 = QDoubleSpinBox(); self.spin_c1.setRange(0.0, 400.0); self.spin_c1.setValue(float(ct.DEFAULT_PARAMS["canny1"]))
        self.spin_c2 = QDoubleSpinBox(); self.spin_c2.setRange(0.0, 400.0); self.spin_c2.setValue(float(ct.DEFAULT_PARAMS["canny2"]))
        frm.addRow("Canny (t1,t2)", self._hbox(self.spin_c1, self.spin_c2))

        self.spin_arrow = QDoubleSpinBox(); self.spin_arrow.setRange(5.0, 200.0); self.spin_arrow.setValue(float(ct.DEFAULT_PARAMS["arrow_len"]))
        frm.addRow("Arrow length", self.spin_arrow)

        box = QGroupBox("Parameters"); box.setLayout(frm)

        # Buttons
        self.bt_open = QPushButton("Open Imageâ€¦")
        self.bt_preview = QPushButton("Preview Contour")
        self.bt_apply = QPushButton("Apply To Overlay")
        self.bt_ok = QPushButton("Close")
        self.bt_ok.clicked.connect(self.accept)
        self.bt_open.clicked.connect(self._choose_image)
        self.bt_preview.clicked.connect(self._preview_contour)
        self.bt_apply.clicked.connect(self._apply_overlay)

        layout = QVBoxLayout(self)
        layout.addWidget(box)
        layout.addWidget(self._path_label)
        layout.addWidget(self._preview, 1)
        layout.addLayout(self._hbox(self.bt_open, self.bt_preview, self.bt_apply, self.bt_ok))

    def _hbox(self, *widgets):
        hb = QHBoxLayout()
        for w in widgets:
            hb.addWidget(w)
        hb.addStretch(1)
        return hb

    def set_image_path(self, path: str) -> bool:
        if not path:
            self._path_label.setText("Image: (none)")
            self._preview.setText("Choose an image first")
            self._img_path = None
            return False
        self._img_path = path
        self._path_label.setText(f"Image: {path}")
        self._preview.setToolTip(path)
        img = cv2.imread(path)
        if img is None:
            self._preview.setText("(could not load image)")
            self._preview.setPixmap(QPixmap())
            return False
        self._set_preview(img)
        return True

    def params(self) -> dict:
        return {
            "method": self.combo_method.currentText(),
            "blur": int(self.spin_blur.value()),
            "morph": int(self.spin_morph.value()),
            "morph_iter": int(self.spin_morph_iter.value()),
            "approx_eps": float(self.spin_eps.value()),
            "thresh_offset": float(self.spin_th_off.value()),
            "canny1": float(self.spin_c1.value()),
            "canny2": float(self.spin_c2.value()),
            "arrow_len": float(self.spin_arrow.value()),
        }

    def _choose_image(self):
        p, _ = QFileDialog.getOpenFileName(self, "Choose Image", "", "Images (*.png *.jpg *.bmp);;All Files (*.*)")
        if p:
            if not self.set_image_path(p):
                self._preview.setText("(failed to load selected image)")

    def _preview_contour(self):
        if not self._img_path:
            self._preview.setText("Choose an image first")
            return
        img = cv2.imread(self._img_path)
        if img is None:
            self._preview.setText("Failed to read image")
            return
        cnt = ct.extract_outer_contour(img, self.params())
        vis = img.copy()
        if cnt is not None and len(cnt) > 1:
            pts = cnt.reshape(-1, 1, 2).astype(np.int32)
            cv2.polylines(vis, [pts], isClosed=False, color=(255, 0, 0), thickness=2)
        self._set_preview(vis)

    def _apply_overlay(self):
        # just emit accept; MainWindow will re-run overlay using these params
        self.accept()

    def _set_preview(self, bgr):
        # Encode to PNG then load to QPixmap (avoids QImage stride issues)
        ok, buf = cv2.imencode('.png', bgr)
        if ok:
            pm = QPixmap()
            pm.loadFromData(buf.tobytes(), 'PNG')
            self._preview.setPixmap(pm.scaled(self._preview.width(), self._preview.height(), Qt.KeepAspectRatio, transformMode=Qt.SmoothTransformation))
        else:
            self._preview.setText("Preview failed")


# --- async helpers injected by Codex ---
import threading

def _to_qpixmap(bgr):
    try:
        import cv2
        from PyQt5.QtGui import QImage, QPixmap
        h, w = bgr.shape[:2]
        rgb = cv2.cvtColor(bgr, cv2.COLOR_BGR2RGB)
        qimg = QImage(rgb.data, w, h, rgb.strides[0], QImage.Format_RGB888)
        return QPixmap.fromImage(qimg)
    except Exception:
        return None



